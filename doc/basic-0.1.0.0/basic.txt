-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | Please see the README on Github at
--   <a>https://github.com/michaeljklein/basic#readme</a>
@package basic
@version 0.1.0.0

module Control.Foldl.Utils

-- | Advance a <a>Fold</a> one step
advanceF :: a -> Fold a b -> Fold a b

-- | Advance a <a>FoldM</a> one step
advanceFM :: Monad m => a -> FoldM m a b -> FoldM m a b

-- | Extract a result from a <a>FoldM</a>
extractM :: Monad m => FoldM m a b -> m b

-- | Join an inner <a>Monad</a>ic value in a <a>FoldM</a>
joinFoldM :: Monad m => FoldM m a (m b) -> FoldM m a b
hoistFoldM :: (forall x. m x -> n x) -> FoldM m a b -> FoldM n a b

module Control.Comonad.CofreeF

-- | A <a>Functor</a> composed with its <a>Cofree</a> <a>Comonad</a>
newtype CofreeF f a
CofreeF :: f (Cofree f a) -> CofreeF f a
[runCofreeF] :: CofreeF f a -> f (Cofree f a)

-- | Hoist a natural transformation to <a>CofreeF</a>
hoistCofreeF :: (Functor f, Functor g) => (forall x. f x -> g x) -> CofreeF f a -> CofreeF g a

-- | Convert the internal <a>Functor</a> of <a>CofreeF</a> from
--   <a>Maybe</a> to any <a>Alternative</a>
hoistCofreeAlt :: Alternative f => CofreeF Maybe a -> CofreeF f a

-- | Effectively attaches the second at the first level where the first
--   fails, e.g. for CofreeF Maybe, this is isomorphic to (&lt;&gt;)
orDown :: Alternative f => CofreeF f a -> CofreeF f a -> CofreeF f a

-- | Convert <a>Maybe</a> to any <a>Alternative</a>
altMaybe :: Alternative f => Maybe a -> f a

-- | Convert the internal <a>Functor</a> of <a>CofreeF</a> from
--   <a>Maybe</a> to any <a>Alternative</a>.
altMaybeT :: MonadPlus m => MaybeT m a -> m a
spanCofreeF :: Monad m => (a -> m Bool) -> FoldM m a b -> CofreeF m a -> m (b, CofreeF m a)
spanCofreeF' :: Monad m => (a -> m Bool) -> (x -> a -> m x) -> x -> (x -> m b) -> CofreeF m a -> m (b, CofreeF m a)
foldCofreeF :: Monad m => (a -> m b) -> FoldM m b c -> CofreeF (MaybeT m) a -> m c
instance GHC.Base.Functor f => GHC.Base.Functor (Control.Comonad.CofreeF.CofreeF f)
instance Control.Comonad.Comonad f => Control.Comonad.Comonad (Control.Comonad.CofreeF.CofreeF f)
instance GHC.Base.Alternative f => GHC.Base.Applicative (Control.Comonad.CofreeF.CofreeF f)
instance (GHC.Base.Alternative f, GHC.Base.Monad f) => GHC.Base.Monad (Control.Comonad.CofreeF.CofreeF f)
instance GHC.Base.Alternative f => GHC.Base.Alternative (Control.Comonad.CofreeF.CofreeF f)
instance Data.Foldable.Foldable f => Data.Foldable.Foldable (Control.Comonad.CofreeF.CofreeF f)
instance Data.Traversable.Traversable f => Data.Traversable.Traversable (Control.Comonad.CofreeF.CofreeF f)

module Control.Foldl1

-- | A <a>Fold</a> over non-empty inputs
newtype Fold1 a b
Fold1 :: (a -> Fold (a, a) b) -> Fold1 a b
[runFold1] :: Fold1 a b -> a -> Fold (a, a) b

-- | A <a>FoldM</a> over non-empty inputs
newtype FoldM1 m a b
FoldM1 :: (a -> FoldM m (a, a) b) -> FoldM1 m a b
[runFoldM1] :: FoldM1 m a b -> a -> FoldM m (a, a) b
toFold1 :: Fold a b -> Fold1 a b
toFoldM1 :: Monad m => FoldM m a b -> FoldM1 m a b

-- | Given a default result, we can transform a <a>Fold</a> that requires
--   an initial value and folds over <tt>(prev value, current value)</tt>
--   into a simple <a>Fold</a>.
fold1 :: b -> Fold1 a b -> Fold a b

-- | <tt>foldPairF</tt> for <a>FoldM</a>
foldM1 :: Monad m => b -> FoldM1 m a b -> FoldM m a b

module Control.Foldl.Except
joinEither :: Either a a -> a

-- | Monadic fold with early result (before folding over an entire input)
--   
--   For example, could define:
--   
--   <pre>
--   countIndent :: FoldE Char m Int
--   countIndent = FoldE (FoldM (i y -&gt; if isSpace y then return (i+1) else throwE i) 0 return)
--   </pre>
newtype FoldE a m b
FoldE :: FoldM (ExceptT b m) a b -> FoldE a m b
[runFoldE] :: FoldE a m b -> FoldM (ExceptT b m) a b

-- | Extract the current result
extractE :: Monad m => FoldE a m b -> m b

-- | Consume no input and return the given value
pureFoldE :: Monad m => b -> FoldE a m b

-- | returnFoldE and pureFoldE should be pretty quick, they end the
--   <a>FoldE</a> at every point.
returnFoldE :: Monad m => m b -> FoldE a m b

-- | Given a default and <a>Foldable</a> collection of ways to parse a
--   <tt>b</tt>, try each (only rewinding up to a single char) and return
--   (Left the_first_to_throwE (Just x)), or recurse.
foldEs :: (Monad m, Foldable t) => FoldE c m (Maybe b) -> t (FoldE c m (Maybe b)) -> CofreeF (MaybeT m) c -> CofreeF (MaybeT m) (Either b c)
foldEs_ :: (Monad m, Foldable t) => t (FoldE c m (Maybe b)) -> CofreeF (MaybeT m) c -> CofreeF (MaybeT m) (Either b c)

-- | <a>foldE1</a> may be combined with <a>foldE0</a> as follows to combine
--   arbitrarily large numbers of <a>FoldE</a>s:
--   
--   <pre>
--   f g -&gt; foldE1 g . foldE0 f
--     :: Monad m =&gt;
--           FoldE a m (Maybe b)
--        -&gt; FoldE a m (Maybe c)
--        -&gt; CofreeF (MaybeT m) a
--        -&gt; CofreeF (MaybeT m) (Either (Either b c) a)
--   
--   f g h -&gt; foldE1 h . foldE1 g . foldE0 f
--     :: Monad m =&gt;
--           FoldE a m (Maybe b)
--        -&gt; FoldE a m (Maybe c1)
--        -&gt; FoldE a m (Maybe c2)
--        -&gt; CofreeF (MaybeT m) a
--        -&gt; CofreeF (MaybeT m) (Either (Either (Either b c1) c2) a)
--   </pre>
--   
--   Or, we may not want to preserve distinct <a>FoldE</a> types:
--   
--   <pre>
--   f g -&gt; fmap (first joinEither) . foldE1 g . foldE0 f
--     :: Monad m =&gt;
--           FoldE c m (Maybe b)
--        -&gt; FoldE c m (Maybe b)
--        -&gt; CofreeF (MaybeT m) c
--        -&gt; CofreeF (MaybeT m) (Either b c)
--   
--   f g h -&gt; fmap (first joinEither) . foldE1 h . fmap (first joinEither) . foldE1 g . foldE0 f
--     :: Monad m =&gt;
--           FoldE c m (Maybe b)
--        -&gt; FoldE c m (Maybe b)
--        -&gt; FoldE c m (Maybe b)
--        -&gt; CofreeF (MaybeT m) c
--        -&gt; CofreeF (MaybeT m) (Either b c)
--   </pre>
foldE1 :: Monad m => FoldE a m (Maybe c) -> CofreeF (MaybeT m) (Either b a) -> CofreeF (MaybeT m) (Either (Either b c) a)
foldE1' :: Monad m => (x -> a -> ExceptT (Maybe c) m x) -> x -> (x -> ExceptT (Maybe c) m (Maybe c)) -> Maybe (Cofree (MaybeT m) (Either b a)) -> m (Maybe (Cofree (MaybeT m) (Either (Either b c) a)))
foldE0 :: Monad m => FoldE a m (Maybe b) -> CofreeF (MaybeT m) a -> CofreeF (MaybeT m) (Either b a)
foldE0' :: Monad m => (x -> a -> ExceptT (Maybe b) m x) -> ExceptT (Maybe b) m x -> (x -> ExceptT (Maybe b) m (Maybe b)) -> Maybe (Cofree (MaybeT m) a) -> m (Maybe (Cofree (MaybeT m) (Either b a)))

-- | <a>FoldE</a> for non-empty inputs
newtype Fold1E a m b
Fold1E :: FoldM1 (ExceptT b m) a b -> Fold1E a m b
[runFold1E] :: Fold1E a m b -> FoldM1 (ExceptT b m) a b
fold1E :: Monad m => b -> Fold1E a m b -> FoldE a m b
foldIf1 :: Monad m => (a -> Bool) -> Fold1E a m (Maybe b) -> FoldE a m (Maybe b)
span1E :: Monad m => (a -> Bool) -> (a -> a -> MaybeT m b) -> Fold1E a m (Maybe b)
span2E :: Monad m => (a -> a -> Bool) -> (a -> a -> MaybeT m b) -> Fold1E a m (Maybe b)
spanIfE2 :: Monad m => (a -> Bool) -> (a -> a -> Bool) -> (a -> a -> MaybeT m b) -> FoldE a m (Maybe b)
parseStringWith :: (Comonad w, Monad m) => (w Char -> w Char -> MaybeT m b) -> FoldE (w Char) m (Maybe b)

-- | If empty, <tt><a>extractM</a></tt>, if the predicate passes then fold
--   with the given fold else <a>throwE</a>.
foldIf :: Monad m => (a -> Bool) -> FoldE a m b -> FoldE a m b
takeWhile1 :: Monad m => (a -> Bool) -> FoldE a m b -> FoldE a m b
takeUntil1 :: Monad m => (a -> Bool) -> FoldE a m b -> FoldE a m b
instance GHC.Base.Monad m => GHC.Base.Functor (Control.Foldl.Except.FoldE a m)

module Data.Range

-- | Possibly-empty strict ranges
data Range a
Range0 :: Range a
Range1 :: !a -> Range a
Range2 :: !a -> !a -> Range a
instance GHC.Base.Functor Data.Range.Range
instance GHC.Show.Show a => GHC.Show.Show (Data.Range.Range a)
instance GHC.Read.Read a => GHC.Read.Read (Data.Range.Range a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Data.Range.Range a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Data.Range.Range a)
instance GHC.Classes.Ord a => GHC.Base.Monoid (Data.Range.Range a)
instance GHC.Base.Applicative Data.Range.Range

module Control.Foldl.UTF8
iterateCofree :: Functor f => i -> (i -> i) -> Cofree f a -> Cofree f (i, a)
enumCofree :: (Enum i, Functor f) => Cofree f a -> Cofree f (i, a)
sizedUncons :: ByteString -> Maybe (Char, Int, ByteString)
unfoldUncons :: (Enum i, Monad m) => ByteString -> CofreeF (MaybeT m) (Char, i, Int)
data StringLit
StringLit :: !ByteString -> !(Range Pos) -> StringLit
[strBytes] :: StringLit -> !ByteString
[strRange] :: StringLit -> !(Range Pos)
emptyStringLit :: StringLit
unsafeSelect :: Range Int -> ByteString -> ByteString
toStringLit :: ByteString -> Range Pos -> StringLit
data Pos
Pos :: !Int -> !Int -> Pos
[charNum] :: Pos -> !Int
[byteNum] :: Pos -> !Int
unfoldUnconsC :: Monad m => ByteString -> CofreeF (MaybeT m) (Env Pos Char)
parseStringE :: Monad m => ByteString -> FoldE (Env Pos Char) m (Maybe StringLit)
type Line = Int
newtype LineT m a
LineT :: WriterT Line m a -> LineT m a
[runLineT] :: LineT m a -> WriterT Line m a
joinEither :: Either a a -> a
prefixF :: (a -> Bool) -> Fold a b -> Fold (a, b) c -> Fold a (c, b)
prefixFM :: Monad m => (a -> Bool) -> FoldM m a b -> FoldM m (a, b) c -> FoldM m a (c, b)

-- | Example use of prefixF
spacedF :: Enum spaces => Fold (Char, spaces) a -> Fold Char (a, spaces)

-- | Example use of prefixFM
spacedFM :: (Enum spaces, Monad m) => FoldM m (Char, spaces) a -> FoldM m Char (a, spaces)
enumF :: Enum i => Fold a i
chunkF :: (a -> Bool) -> Fold a b -> Fold b c -> Fold a c
chunkFM :: Monad m => (a -> Bool) -> FoldM m a b -> FoldM m b c -> FoldM m a c

-- | Example usage of chunkF
linesF :: Fold Char b -> Fold b c -> Fold Char c

-- | Example usage of chunkFM
linesFM :: Monad m => FoldM m Char b -> FoldM m b c -> FoldM m Char c
instance GHC.Show.Show Control.Foldl.UTF8.StringLit
instance GHC.Classes.Ord Control.Foldl.UTF8.StringLit
instance GHC.Classes.Eq Control.Foldl.UTF8.StringLit
instance GHC.Read.Read Control.Foldl.UTF8.Pos
instance GHC.Show.Show Control.Foldl.UTF8.Pos
instance GHC.Classes.Ord Control.Foldl.UTF8.Pos
instance GHC.Classes.Eq Control.Foldl.UTF8.Pos

module Data.Token
newtype TokenStateT i m a
TokenStateT :: StateT (Fold ByteString (TokenState i)) (ReaderT ByteString m) a -> TokenStateT i m a
[runTokenStateT] :: TokenStateT i m a -> StateT (Fold ByteString (TokenState i)) (ReaderT ByteString m) a
data TokenState i
TokenState :: !(Token i) -> !(Token i) -> Trie i -> TokenState i
[thisToken] :: TokenState i -> !(Token i)
[lastToken] :: TokenState i -> !(Token i)
[tokenTrie] :: TokenState i -> Trie i
type Token i = i
foldTrie :: Enum i => Fold ByteString (TokenState i)
foldTrieM :: (Enum i, Monad m) => FoldM m ByteString (TokenState i)
fst3 :: (a, b, c) -> a

module Lib

-- | Assumes the initial is True
foldEitherP :: (a -> Bool) -> Fold a b -> Fold a c -> Fold (Either b c) d -> Fold a d

-- | Source location
data Loc
Loc :: !Int -> !Int -> !Int -> Loc
[lineNum] :: Loc -> !Int
[beginLoc] :: Loc -> !Int
[endLoc] :: Loc -> !Int
newtype Token
Token :: Int -> Token
[unToken] :: Token -> Int

-- | Make or lookup a <a>Token</a>
class MonadFail m => MonadToken m
token :: MonadToken m => Loc -> Text -> m Token
getToken :: MonadToken m => Token -> m (Loc, Text)
data TokenState
TokenState :: !Token -> !(Trie Token) -> !(IntMap (Loc, ByteString)) -> TokenState
[currentToken] :: TokenState -> !Token
[lookupTrie] :: TokenState -> !(Trie Token)
[tokenMap] :: TokenState -> !(IntMap (Loc, ByteString))
newtype TokenT m a
TokenT :: StateT TokenState m a -> TokenT m a
[getTokenT] :: TokenT m a -> StateT TokenState m a
runTokenT :: Monad m => TokenT m a -> m (a, TokenState)
parseText :: Monad m => Text -> Cofree (ReaderT Char m) a -> Either a (m a)

-- | Strict homogenous pairs
data Pair a
Pair :: !a -> !a -> Pair a
[fstPair] :: Pair a -> !a
[sndPair] :: Pair a -> !a
enumCofree :: (Enum i, Functor m) => Cofree m a -> WriterT i (Cofree m) a
mark :: Functor m => WriterT i (Cofree m) a -> WriterT (Pair i) (Cofree m) a

-- | Extract the current marked range
getMark :: WriterT (Pair i) (Cofree m) a -> Pair i
unMarkToken :: (Enum i, MonadToken m) => i -> Text -> WriterT (Pair i) (Cofree m) a -> m (Token, WriterT i (Cofree m) a)
selectToken :: (Enum i, MonadToken m) => i -> Text -> Pair i -> m Token
selectText :: (Enum i, MonadFail m) => Text -> Pair i -> m Text

-- | Use a Cofree Reader to take all for a token
takeToken :: (Enum i, MonadToken m) => i -> Text -> ReaderT a m (Cofree (ReaderT a m) Bool) -> WriterT (Pair i) (Cofree m) a -> m (Token, WriterT i (Cofree m) a)

-- | Drop using a Cofree Reader to encode a (possibly stateful) predicate
dropCofreeReader :: Monad m => ReaderT a m (Cofree (ReaderT a m) Bool) -> WriterT (Pair i) (Cofree m) a -> m (WriterT (Pair i) (Cofree m) a)
unitReader :: Applicative m => (a -> Bool) -> ReaderT a m (Cofree (ReaderT a m) Bool)
unitReaderM :: Applicative m => (a -> m Bool) -> ReaderT a m (Cofree (ReaderT a m) Bool)

-- | Example usage of <a>unitReader</a> to read digits
digitReader :: Applicative m => ReaderT Char m (Cofree (ReaderT Char m) Bool)
fromList :: Alternative f => [a] -> f (Cofree f a)
foldlChar :: Fold Char b -> Fold Text b
foldlChar' :: Fold Char b -> Fold Text b

-- | Fold into groups, then fold those groups.
--   
--   Roughly equivalent to:
--   
--   <pre>
--   fold fy . map (fold fx) . groupBy p == groupByF
--   </pre>
groupByF :: (a -> a -> Bool) -> Fold a b -> Fold b c -> Fold a c
groupByF' :: (a -> a -> Bool) -> Fold a b -> Fold b c -> Fold a c
groupByF'' :: (a -> a -> Bool) -> Fold a b -> Fold b c -> Fold a c

-- | <a>Fold</a> with the first <a>Fold</a> until the predicate returns
--   <a>False</a>, then with the second <a>Fold</a>.
--   
--   For example:
--   
--   <pre>
--   Î»&gt; fold (spanF (<a>sumF (x -</a> liftA2 (,) (pure x) ((+ x) <a>$</a> sumF))) $ <a>1..10</a>
--   </pre>
spanF :: (a -> Bool) -> Fold a b -> (b -> Fold a c) -> Fold a c
sumF :: Num a => Fold a a

-- | Fold as a Tree where pure values are Left and subtrees are folded into
--   Right (ignoring unmatched right (endP) values) treeF :: (a -&gt; Bool)
--   -&gt; (a -&gt; Bool) -&gt; Fold (Either a b) b -&gt; Fold a b treeF
--   beginP endP f = simplify $ extract <a>$</a> treeFM' beginP endP (const
--   (return ())) (generalize f)
nothingT :: Applicative m => MaybeT m a
pushTop :: Monad m => a -> NonEmpty a -> m (NonEmpty a)
feedTop :: Monad m => a -> NonEmpty (FoldM m (Either a b) c) -> m (NonEmpty (FoldM m (Either a b) c))
popTop :: MonadReader (FoldM m (Either a b) b) m => NonEmpty (FoldM m (Either a b) b) -> m (NonEmpty (FoldM m (Either a b) b))
pushFeedPop :: MonadReader (FoldM m (Either a b) b) m => (a -> Bool) -> (a -> Bool) -> FoldM m (Either a b) b -> a -> NonEmpty (FoldM m (Either a b) b) -> m (NonEmpty (FoldM m (Either a b) b))
pushFeedPopFold :: MonadReader (FoldM m (Either a b) b) m => (a -> Bool) -> (a -> Bool) -> FoldM m (Either a b) b -> FoldM m a (NonEmpty (FoldM m (Either a b) b))
collect :: Enum i => (a -> Bool) -> Fold (Either a i) b -> Fold a b
collectM_ :: (Enum i, Monad m) => (a -> Bool) -> FoldM m (Either a i) b -> FoldM m a b
collectM :: (Enum i, Monad m) => (a -> m Bool) -> FoldM m (Either a i) b -> FoldM m a b
newtype Spaces
Spaces :: Int -> Spaces
[numSpaces] :: Spaces -> Int
type MaybeSpaces a = Either Spaces a
swapEither :: Either a b -> Either b a
collectSpaces :: Fold (MaybeSpaces Char) b -> Fold Char b
collectSpacesM :: Monad m => FoldM m (MaybeSpaces Char) b -> FoldM m Char b
foldSpaces :: Fold Char b -> Fold (MaybeSpaces b) c -> Fold (MaybeSpaces Char) c
foldSpacesM :: Monad m => FoldM m Char b -> FoldM m (MaybeSpaces b) c -> FoldM m (MaybeSpaces Char) c
collectFoldSpaces :: Fold Char a -> Fold (MaybeSpaces a) b -> Fold Char b
collectFoldSpacesM :: Monad m => FoldM m Char a -> FoldM m (MaybeSpaces a) b -> FoldM m Char b
exampleCountChars :: Fold Char Int
stringF :: Fold Char String
newtype FreeReaderT a m b
FreeReaderT :: FreeT (Reader a) m b -> FreeReaderT a m b
[runFreeReaderT] :: FreeReaderT a m b -> FreeT (Reader a) m b
class Monad m => MonadReader a m | m -> a
withRead :: MonadReader a m => (a -> m b) -> m b
cofreeRead :: MonadReader a m => m (Cofree m a)
hoistFreeReaderT :: Monad m => (forall x. m x -> n x) -> FreeReaderT a m b -> FreeReaderT a n b
feedF :: a -> Fold a b -> Fold a b
feedFM :: Monad m => a -> FoldM m a b -> FoldM m a b
joinFoldM :: Monad m => FoldM m a (m b) -> FoldM m a b
returnFoldM :: Monad m => FoldM m (m a) b -> FoldM m a b
bindFoldM :: Monad m => FoldM m a b -> FoldM m (m a) b
mapMFoldM :: Monad m => (b -> m c) -> FoldM m a b -> FoldM m a c
dimapFoldM :: Monad m => (b -> m a) -> (c -> m d) -> FoldM m a c -> FoldM m b d
extractM :: Monad m => FoldM m a b -> m b
swapMaybe :: a -> Maybe b -> Maybe a
endTreeFM :: Monad m => FoldM m a (Cofree (MaybeT (FoldM m a)) b) -> FoldM m a (Maybe b)

-- | run the resulting fold over a groupBy-like function and collect the
--   results, including the continuation fold runTreeFMSection :: FoldM m a
--   (Cofree (MaybeT (FoldM m a)) b) -&gt; FoldM m b c -&gt; ((FoldM m a b
--   -&gt; FoldM m b c -&gt; r) -&gt; r) -&gt; FoldM m a (Cofree (MaybeT
--   (FoldM m a)) c)
stackNonEmpty :: Monad m => (forall x. (x -> NonEmpty x -> m (NonEmpty x)) -> (NonEmpty x -> m (x, Maybe (NonEmpty x))) -> r) -> r
pushNonEmpty :: Monad m => x -> NonEmpty x -> m (NonEmpty x)
popNonEmpty :: Monad m => NonEmpty x -> m (x, Maybe (NonEmpty x))

-- | A small demonstration of the power of <tt>treeF</tt> toTreeF :: (a
--   -&gt; Bool) -&gt; (a -&gt; Bool) -&gt; Fold a (FreeT Identity [] a)
--   toTreeF px py = treeF px py $ Fold (x y -&gt; case y of Left y' -&gt;
--   x &lt;&gt; [Pure y' ] Right y' -&gt; x &lt;&gt; [Free (Identity y')] )
--   [] FreeT
printFreeT :: FreeT Identity [] String -> IO ()
printFreeF :: FreeF Identity String (FreeT Identity [] String) -> IO ()
enumF :: Enum i => Fold (i, a) b -> Fold a b
enumF' :: Enum i => Fold (i, a) b -> Fold a b
countF :: Enum i => Fold a i

-- | pre-fold, pass the results of the first Fold as a an argument to the
--   second fold (like a scan):
--   
--   <pre>
--   preFold fx fy == fold . scanl (fmap fx . join (,))
--   </pre>
preFold :: Fold a b -> Fold (b, a) c -> Fold a c
newtype Fold1 a b
Fold1 :: ReaderT a (Fold a) b -> Fold1 a b
[runFold1] :: Fold1 a b -> ReaderT a (Fold a) b

-- | Fold into groups using a monadic action, see <a>groupByF</a>
groupByFM :: Monad m => (a -> a -> m Bool) -> FoldM m a b -> FoldM m b c -> FoldM m a c
groupByFM' :: Monad m => (a -> a -> m Bool) -> FoldM m a b -> FoldM m b c -> FoldM m a c
snd3 :: (a, b, c) -> b

-- | Fold using the first Fold until False, then pass the result to the
--   second Fold and continue spanF :: (a -&gt; Bool) -&gt; Fold a b -&gt;
--   (b -&gt; Fold a c) -&gt; Fold a c
foldCofree :: Foldable t => Cofree ((->) (b, a)) b -> t a -> b
fold2 :: Foldable t => (b -> a -> b) -> (b -> (a, a) -> b) -> b -> t a -> b
fold2Cofree :: Foldable t => b -> (a -> b) -> (b -> a -> a -> b) -> t a -> b
fold3Cofree :: Foldable t => b -> (a -> b) -> (a -> a -> b) -> (b -> a -> a -> a -> b) -> t a -> b
someFunc :: IO ()
instance GHC.Base.Monad m => GHC.Base.Functor (Lib.FreeReaderT a m)
instance GHC.Show.Show Lib.Spaces
instance GHC.Read.Read Lib.Spaces
instance GHC.Classes.Ord Lib.Spaces
instance GHC.Classes.Eq Lib.Spaces
instance GHC.Base.Functor Lib.Pair
instance GHC.Show.Show a => GHC.Show.Show (Lib.Pair a)
instance GHC.Classes.Ord a => GHC.Classes.Ord (Lib.Pair a)
instance GHC.Classes.Eq a => GHC.Classes.Eq (Lib.Pair a)
instance GHC.Base.Functor m => GHC.Base.Functor (Lib.TokenT m)
instance GHC.Enum.Bounded Lib.Token
instance GHC.Read.Read Lib.Loc
instance GHC.Show.Show Lib.Loc
instance GHC.Classes.Ord Lib.Loc
instance GHC.Classes.Eq Lib.Loc
instance GHC.Base.Monad m => Lib.MonadReader a (Lib.FreeReaderT a m)
instance GHC.Base.Monad m => GHC.Base.Applicative (Lib.FreeReaderT a m)
instance GHC.Base.Monad m => GHC.Base.Monad (Lib.FreeReaderT a m)
instance Control.Monad.Trans.Class.MonadTrans (Lib.FreeReaderT a)
instance GHC.Enum.Enum Lib.Spaces
instance GHC.Base.Monad m => GHC.Base.Applicative (Lib.TokenT m)
instance GHC.Base.Monad m => GHC.Base.Monad (Lib.TokenT m)
instance Control.Monad.Trans.Class.MonadTrans Lib.TokenT
instance Control.Monad.Fail.MonadFail m => Control.Monad.Fail.MonadFail (Lib.TokenT m)
instance Control.Monad.Fail.MonadFail m => Lib.MonadToken (Lib.TokenT m)
